import csv
import json
import os
import uuid
from datetime import datetime

# where the engine wrote scenarios
BDD_CSV_PATH = "src/coverage_engine/outbound/bdd_scenarios.csv"

# where we'll save the Postman collection
OUT_DIR = "src/postman_export/outbound"


def read_bdd_csv(csv_path):
    """
    Read bdd_scenarios.csv and group rows by (apiName, endpointName, method, path).
    Returns dict keyed by that 4-tuple. Each value = list of scenario dicts.
    """
    grouped = {}
    if not os.path.exists(csv_path):
        raise FileNotFoundError(
            f"Could not find {csv_path}. Did you run the coverage runner first?"
        )

    with open(csv_path, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            key = (
                row["apiName"],
                row["endpointName"],
                row["method"],
                row["path"],
            )
            scenario = {
                "scenario_id": row["scenario_id"],
                # undo the "\n" escaping so it's readable in Postman
                "gherkin_and_curl": row["gherkin_and_curl"].replace("\\n", "\n"),
            }
            grouped.setdefault(key, []).append(scenario)

    return grouped


def build_postman_item_for_endpoint(api_name, endpoint_name, method, path, scenarios):
    """
    Build a single Postman request item with:
    - name
    - request: { method, url, headers, body }
    - event: "test" script that embeds the generated BDD text (gherkin_and_curl)

    Right now we don't have dynamic headers / body / query per scenario because
    that requires deeper mapping. We stub a generic request using the path.
    """

    # We'll assume https://dummy.local as host, and path is something like "/api_1/resource_2"
    # We split path into segments and build Postman's url struct.
    # Postman wants ["api_1","resource_2"] etc.
    clean_path = path.lstrip("/")
    path_segments = [seg for seg in clean_path.split("/") if seg]

    url_obj = {
        "raw": f"https://dummy.local{path}",
        "protocol": "https",
        "host": ["dummy", "local"],
        "path": path_segments,
    }

    # Build the JS test script that embeds all scenarios' gherkin
    # We'll put it as a multi-line comment for readability inside Postman "Tests".
    gherkin_lines = []
    gherkin_lines.append("// Auto-generated coverage scenarios:")
    for sc in scenarios:
        gherkin_lines.append(f"// Scenario {sc['scenario_id']}:")
        for line in sc["gherkin_and_curl"].splitlines():
            # prefix with // so Postman treats it as a comment
            gherkin_lines.append("// " + line)
        gherkin_lines.append("//")  # spacer

    test_event = {
        "listen": "test",
        "script": {
            "type": "text/javascript",
            "exec": gherkin_lines
        }
    }

    # Basic request object
    request_obj = {
        "method": method.upper(),
        "header": [
            # you can add defaults here or leave empty
            {"key": "Accept", "value": "application/json"},
            {"key": "Content-Type", "value": "application/json"}
        ],
        "url": url_obj,
        # minimal body stub for POST/PUT/PATCH
        "body": {
            "mode": "raw",
            "raw": "{ \"example\": true }"
        } if method.upper() in ("POST", "PUT", "PATCH") else None
    }

    # remove body if method shouldn't have body
    if request_obj["body"] is None:
        del request_obj["body"]

    item = {
        "name": f"{api_name} :: {endpoint_name} [{method} {path}]",
        "request": request_obj,
        "event": [test_event],
    }

    return item


def build_postman_collection(grouped_rows):
    """
    Build a Postman v2.1 collection JSON from the grouped_rows.
    We'll make a top-level collection with folders per apiName.
    Each folder contains requests for that API.
    """

    # shape: { apiName: [ item1, item2, ... ] }
    apis = {}
    for (api_name, endpoint_name, method, path), scenarios in grouped_rows.items():
        item = build_postman_item_for_endpoint(api_name, endpoint_name, method, path, scenarios)
        apis.setdefault(api_name, []).append(item)

    # convert that map into Postman collection "item" format
    # each API becomes a folder with its own "item" list
    top_level_items = []
    for api_name, requests in apis.items():
        top_level_items.append({
            "name": api_name,
            "item": requests
        })

    collection = {
        "info": {
            "name": f"Coverage Collection {datetime.utcnow().isoformat()}Z",
            "_postman_id": str(uuid.uuid4()),
            "description": "Autogenerated from coverage_engine BDD scenarios + parameter coverage.",
            "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
        },
        "item": top_level_items
    }

    return collection


def save_collection(coll):
    os.makedirs(OUT_DIR, exist_ok=True)
    ts = int(datetime.utcnow().timestamp())
    out_path = os.path.join(
        OUT_DIR,
        f"postman_{ts}.json",
    )
    with open(out_path, "w", encoding="utf-8") as f:
        json.dump(coll, f, indent=2)
    abs_path = os.path.abspath(out_path)
    print(f"[OK] Postman collection saved at: {abs_path}")
    return abs_path


def main():
    grouped = read_bdd_csv(BDD_CSV_PATH)
    coll = build_postman_collection(grouped)
    save_collection(coll)


if __name__ == "__main__":
    main()
